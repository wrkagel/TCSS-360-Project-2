package model;

import control.ModelListener;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;

/*
TCSS 360 Project #2
Group 8
RJ Alabado, Walter Kagel, Taehong Kim
 */

/**
 * Test class for the CPU. Implements ModelListener so it can get the updates generated by the CPU.
 * @author Group 8, Lead: Walter Kagel
 * @version 10/28/2020
 */
class CPUTest implements ModelListener {

    private Memory mem;

    private CPU cpu;

    private ArrayList<String> names;

    private ArrayList<Object> cpuValues;

    private String output = "";

    private String input = "";

    @BeforeEach
    void initialize() {
        mem = new Memory();
        cpu = new CPU(mem);
        cpu.addListener(this);
        names = new ArrayList<String>();
        cpuValues = new ArrayList<Object>();
    }

    /**
     * This tests that loading a short into the accumulator works. Also tests that load
     * calls listener for all of the expected registers and flags.
     */
    @Test
    void loadShortImmediateAccumulator() {
        mem.setByte((short) 0, (byte) 0xC0);
        mem.setByte((short) 1, (byte) 0xA2);
        mem.setByte((short) 2, (byte) 0xCF);
        cpu.fetchExecute(true);
        String[] expectedNames = new String[] {"programCounter", "instructionSpecifier", "operandSpecifier",
                "operand", "accumulator", "index", "negativeFlag", "zeroFlag"};
        short[] numberValues = new short[] {(short) 3, (short) 0x00C0, (short) 0xA2CF, (short) 0xA2CF,
                (short) 0xA2CF, (short) 0};
        for (int i = 0; i < 6; i++) {
            assertEquals(expectedNames[i], names.get(i));
            assertEquals(numberValues[i], (short) cpuValues.get(i));
        }
        assertEquals(expectedNames[6], names.get(6));
        assertEquals(expectedNames[7], names.get(7));
        assertTrue((boolean) cpuValues.get(6));
        assertFalse((boolean) cpuValues.get(7));
    }

    /**
     * This test is being used to ensure that the direct addressing mode works properly.
     */
    @Test
    void loadShortDirectAccumulator() {
        mem.setByte((short) 0, (byte) 0xC1);
        mem.setByte((short) 1, (byte) 0x00);
        mem.setByte((short) 2, (byte) 0x04);
        mem.setShort((short) 4, (short) 0x0F01);
        cpu.fetchExecute(true);
        assertEquals((short) 0x0F01, (short) cpuValues.get(4));
    }

    /**
     * Tests that when the register bit is 1 load puts the operand into the index.
     */
    @Test
    void loadShortImmediateIndex() {
        mem.setByte((short) 0, (byte) 0xC8);
        mem.setByte((short) 1, (byte) 0xA2);
        mem.setByte((short) 2, (byte) 0xCF);
        cpu.fetchExecute(true);
        assertEquals((short) 0xA2CF, (short) cpuValues.get(5));
    }

    /**
     * Tests that loading a byte works and that it only replaces the least significant byte of the register.
     */
    @Test
    void loadByteImmediateAccumulator() {
        mem.setByte((short) 0, (byte) 0xC0);
        mem.setByte((short) 1, (byte) 0x71);
        mem.setByte((short) 2, (byte) 0x71);
        mem.setByte((short) 3, (byte) 0xD0);
        mem.setByte((short) 4, (byte) 0x00);
        mem.setByte((short) 5, (byte) 0xF2);
        cpu.fetchExecute(false);
        cpu.fetchExecute(true);
        assertEquals((short) 0x71F2, cpuValues.get(4));
    }

    /**
     * Tests that loading a byte works and that it only replaces the least significant byte of the register.
     */
    @Test
    void loadByteImmediateIndex() {
        mem.setByte((short) 0, (byte) 0xC8);
        mem.setByte((short) 1, (byte) 0x71);
        mem.setByte((short) 2, (byte) 0x71);
        mem.setByte((short) 3, (byte) 0xD8);
        mem.setByte((short) 4, (byte) 0x00);
        mem.setByte((short) 5, (byte) 0xF2);
        cpu.fetchExecute(false);
        cpu.fetchExecute(true);
        assertEquals((short) 0x71F2, cpuValues.get(5));
    }

    /**
     * Tests that storing a short using direct addressing works properly.
     */
    @Test
    void storeShortDirectAccumulator() {
        //Load something into the accumulator and store it at the address specified.
        byte[] memInitial = new byte[] {(byte) 0xC0, (byte) 0x27, (byte) 0xFF, (byte) 0xE1, (byte) 0x29,
                (byte) 0x53};
        for (int i = 0; i < memInitial.length; i++) mem.setByte((short) i, memInitial[i]);
        //Fetch execute called twice to run both instructions.
        cpu.fetchExecute(false);
        cpu.fetchExecute(false);
        assertEquals((short) 0x27FF, mem.getShort((short) 0x2953));
    }

    /**
     * Tests that a direct addressing mode store works with short value.
     */
    @Test
    void storeShortDirectIndex() {
        //Load something into the index and store it at the address specified.
        byte[] memInitial = new byte[] {(byte) 0xC8, (byte) 0xD1, (byte) 0x80, (byte) 0xE9, (byte) 0xF7,
                (byte) 0x00};
        for (int i = 0; i < memInitial.length; i++) mem.setByte((short) i, memInitial[i]);
        //Fetch execute called twice to run both instructions.
        cpu.fetchExecute(false);
        cpu.fetchExecute(false);
        assertEquals((short) 0xD180, mem.getShort((short) 0xF700));
    }

    @Test
    void storeByteDirectAccumulator() {
        //Load something into the accumulator and store it at the address specified.
        byte[] memInitial = new byte[] {(byte) 0xC0, (byte) 0x27, (byte) 0xFF, (byte) 0xF1, (byte) 0x29,
                (byte) 0x53};
        for (int i = 0; i < memInitial.length; i++) mem.setByte((short) i, memInitial[i]);
        //Fetch execute called twice to run both instructions.
        cpu.fetchExecute(false);
        cpu.fetchExecute(false);
        assertEquals((byte) 0xFF, mem.getByte((short) 0x2953));
        assertEquals((byte) 0x00, mem.getByte((short) 0x2954));
    }

    @Test
    void storeByteDirectIndex() {
        //Load something into the index and store it at the address specified.
        byte[] memInitial = new byte[] {(byte) 0xC8, (byte) 0xD1, (byte) 0x80, (byte) 0xF9, (byte) 0xF7,
                (byte) 0x00};
        for (int i = 0; i < memInitial.length; i++) mem.setByte((short) i, memInitial[i]);
        //Fetch execute called twice to run both instructions.
        cpu.fetchExecute(false);
        cpu.fetchExecute(false);
        assertEquals((byte) 0x80, mem.getByte((short) 0xF700));
        assertEquals((byte) 0x00, mem.getByte((short) 0xF701));
    }

    /**
     * Test that attempting to use the immediate addressing mode for store throws an error.
     */
    @Test
    void storeIllegalAddressingMode() {
        //Load something into the index, then call store with the immediate addressing mode.
        byte[] memInitial = new byte[] {(byte) 0xC8, (byte) 0xD1, (byte) 0x80, (byte) 0xF8, (byte) 0xF7,
                (byte) 0x00};
        for (int i = 0; i < memInitial.length; i++) mem.setByte((short) i, memInitial[i]);
        //Fetch execute called twice to run both instructions.
        cpu.fetchExecute(false);
        assertThrows(IllegalArgumentException.class, () -> cpu.fetchExecute(false));
    }

    /**
     * Test inputting a single character with direct addressing mode.
     */
    @Test
    void charInputDirect() {
        mem.setByte((short) 0, (byte) 0x49);
        mem.setByte((short) 1, (byte) 0x00);
        mem.setByte((short) 2, (byte) 0x01);
        input = "y";
        cpu.fetchExecute(false);
        assertEquals('y', (char) mem.getByte((short) 0x0001));
    }

    /**
     * Test a single character output with immediate addressing mode.
     */
    @Test
    void charOutputImmediate() {
        mem.setByte((short) 0, (byte) 0x50);
        mem.setByte((short) 1, (byte) 0x00);
        mem.setByte((short) 2, (byte) 0x35);
        cpu.fetchExecute(false);
        assertEquals("5", output);
    }

    /**
     * Test single character output with direct addressing mode.
     */
    @Test
    void charOutputDirect() {
        mem.setByte((short) 0, (byte) 0x51);
        mem.setByte((short) 1, (byte) 0xA5);
        mem.setByte((short) 2, (byte) 0x11);
        mem.setByte((short) 0xA511, (byte) 0x0A);
        cpu.fetchExecute(false);
        assertEquals("\n", output);
    }

    /**
     * Test output of a simple string with direct addressing mode;
     */
    @Test
    void stringOutDirect() {
        mem.setByte((short) 0, (byte) 0x41);
        mem.setByte((short) 1, (byte) 0x22);
        mem.setByte((short) 2, (byte) 0x22);
        String testString = "I am the walrus\n I am the eggman\n These are the wrong lyrics! 556";
        byte[] testBytes = testString.getBytes();
        for (int i = 0; i < testBytes.length; i++) {
            mem.setByte((short) (0x2222 + i), testBytes[i]);
        }
        cpu.fetchExecute(false);
        assertEquals(testString, output);
    }

    /**
     * Tests that moving the stack pointer to the accumulator works.
     */
    @Test
    void moveSPToAccumulator() {
        mem.setByte((short) 0, (byte) 0x02);
        cpu.fetchExecute(true);
        assertEquals((short) 0xFBCF, cpuValues.get(0));
    }

    /**
     * Tests that the N flag is properly moved into the accumulator.
     */
    @Test
    void moveNFlagToAccumulator() {
        //First instruction sets N flag, then moves flags into accumulator
        mem.setByte((short) 0, (byte) 0xC0);
        mem.setByte((short) 1, (byte) 0xA2);
        mem.setByte((short) 2, (byte) 0xCF);
        mem.setByte((short) 3, (byte) 0x03);
        cpu.fetchExecute(false);
        cpu.fetchExecute(true);
        assertEquals((short) 8, cpuValues.get(0));
    }

    //Everything past here is implementing the ModelListener, so the test class can get feedback from the CPU.

    /**
     * Used to pass input to the CPU for testing.
     * @return input string that should be set during individual test
     */
    @Override
    public String getInput() {
        return input;
    }

    /**
     * Grabs the register updates generated by the CPU and adds them to an ArrayList.
     * @param name name of register
     * @param value value of register
     */
    @Override
    public void registerUpdate(String name, Short value) {
        names.add(name);
        cpuValues.add(value);
    }

    /**
     * Grabs the flag updates generated by the CPU and adds them to an ArrayList.
     * @param name of the flag to be updated.
     * @param value if the flag is set true, false otherwise.
     */
    @Override
    public void flagUpdate(String name, boolean value) {
        names.add(name);
        cpuValues.add(value);
    }

    /**
     * Not implemented as CPUTest has direct access to the memory used during the test.
     * @param values a full copy of memory.
     */
    @Override
    public void memoryUpdate(byte[] values) {

    }

    /**
     * Grabs any generated output text.
     * @param outText generated output
     */
    @Override
    public void output(String outText) {
        output = outText;
    }

    /**
     * Not implemented since the CPU throws errors that will be caught by the Machine and then passed
     * to the listener. Thus, no listener.errorMessage() methods will be called while testing CPU.
     * @param message the error message.
     */
    @Override
    public void errorMessage(String message) {

    }
}